<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Go学习-Mac环境配置Golang开发环境及学习项目.]]></title>
      <url>%2F2017%2F03%2F25%2FGo%E5%AD%A6%E4%B9%A0-Mac%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AEGolang%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%8F%8A%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%2F</url>
      <content type="text"><![CDATA[一、下载安装Golang的SDK. Go下载官网:https://golang.org/dl/ 二、配置环境变量 默认安装目录 /usr/local/go 目录 编辑环境变量 1vi ~/.bash_profile GOPATH是项目目录，根据自己的项目设置. GOPATH如果有多个目录，用冒号:分割 12345export GOROOT=/usr/local/goexport GOBIN=$GOROOT/binexport GOARCH=amd64export GOOS=darwinexport GOPATH=/Users/用户名/Desktop/xxxx1:/Users/用户名/Desktop/xxxx2 编译生效 1source ~/.bash_profile 查看Go环境变量 1go env 三、使用Gogland或IDEA安装Go插件GOPATH下需要建立3个目录：bin 存储编译后的可执行文件；pkg 存放编译后生成的包文件；src 存放项目的源码； 四、Golang项目一个golang电子书介绍如何与golang建立一个网站:https://github.com/astaxie/build-web-application-with-golang高性能Web框架:https://github.com/astaxie/beego]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Cocoapods进阶-制作私有Cocoapods仓库。]]></title>
      <url>%2F2017%2F03%2F05%2FCocoapods%E8%BF%9B%E9%98%B6-%E5%88%B6%E4%BD%9C%E7%A7%81%E6%9C%89Cocoapods%E4%BB%93%E5%BA%93%E3%80%82%2F</url>
      <content type="text"><![CDATA[1.克隆仓库到本地1git clone ********** 2.制作仓库索引文件 .podspec1pod spec create xxxxxxx 3.编辑 podspec 文件12345678910111213141516171819202122232425Pod::Spec.new do |s| s.name = &quot;LuKit&quot; // 仓库名字 s.version = &quot;0.0.1&quot; // 仓库版本 s.summary = &quot;A custom framework.&quot; // 仓库简介，搜索的关键词 s.homepage = &quot;https://github.com/RamboLouis/LuKit&quot; // 主页地址 s.license = &quot;MIT&quot; // 许可证 # s.license = &#123; :type =&gt; &quot;MIT&quot;, :file =&gt; &quot;LICENSE&quot; &#125; s.author = &#123; &quot;RamboLu&quot; =&gt; &quot;coderambolu@gmail.com&quot; &#125; // 作者 # s.platform = :ios s.platform = :ios, &quot;9.0&quot; // 仓库使用平台 s.source = &#123; :git =&gt; &quot;https://github.com/RamboLouis/LuKit.git&quot;, :tag =&gt; s.version &#125; // Git仓库地址 s.source_files = &quot;Classes/*.swift&quot; // 需要包含的源文件 s.requires_arc = true // 是否要求ARC # s.dependency &quot;JSONKit&quot;, &quot;~&gt; 1.4&quot; // 仓库中只用到的依赖库 # s.pod_target_xcconfig = &#123; &apos;SWIFT_VERSION&apos; =&gt; &apos;3.0&apos; &#125; // 指定只用swift 3.0版本end 4.打标签和推送版本Ps: 命令行和SourceTree方式。 命令行方式 1234567// 推送版本git add -A &amp;&amp; git commit -m &quot;Release 1.0.0.&quot;git push origin master// 打标签git tag &apos;1.0.0&apos;git push --tags SourceTree方式 Ps: 推送版本。 Ps: 打标签。 5.验证.podspec编辑好后最好先验证 .podspec 是否有有效 1pod spec lint Ps: 验证成功。 6.发布到CocoaPodsCocoaPods 现在使用Trunk 服务来发布自己的pod，所以需要 注册 pod账户 1pod trunk register ******@***.com &quot;****&quot; 查询注册信息 1pod trunk me 推送到pod仓库 1pod trunk push ******.podspec Ps: 推送成功。 PS：出现问题 source_files找不到匹配文件 1- ERROR | [iOS] file patterns: The `source_files` pattern did not match any file. 建议：更改成Classes为根目录。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ReactNative学习-什么是iflux?]]></title>
      <url>%2F2017%2F03%2F03%2FReactNative%E5%AD%A6%E4%B9%A0-%E4%BB%80%E4%B9%88%E6%98%AFiflux%2F</url>
      <content type="text"><![CDATA[什么是iflux ?iflux = immutable.js + react.js 什么是React.js ?React.js犹如Facebook的文化基因所强调的一样move fast and break things, 在快速前进中打破了很多我们对于web开发的固有认识。更厉害的是React把这种创新平移到移动开发(React native)实现了Learn once, Write everywhere. React的特点。 强调组件化的开发方式（更高的抽象层次，更好的分离关注点） 声明式的开发风格（更好的表现力） 单向的数据流动（简单可预测） 超高性能的渲染60fps不是梦 （掌声在哪里？） 最大的创新源于virtual dom （以及virtual native） 轻量，可以在现有的系统中快速试错 精确的生命周期，更简单的整合第三方的库(jquery) 关于更多因为React的定位就是轻量级高效组件式的view library，但是在我们实际的应用开发工程中不仅仅需要处理view的问题，更复杂的是对于状态的控制。官方的flux架构提供了一个很好的针对React的架构指导，但是代码量很大。说到底flux就是在解决一个数据流向以及控制状态变化问题。这点om确实做的非常出色，借助于Clojure的数据的特性（1. 数据不可变 2. 持久化数据结构 3.共享数据结构）在不断的追寻下，immutable.js出现在了眼前，如获至宝。随着对immutable.js深入挖掘，发现正好契合了React的架构特点，可以使用Immutable很好的管理我们的Store，因为Immutable强调值语义，能够更好的追踪状态的变化(cursor)且带来了更好的性能。 整体思路 建议：优先选择connectToStore 1234567891011121314151617181920+-----------------------+| WebApi |+-----------------------+ | \|/+-----------------------+| Store（immutable） |&lt;-----++-----------------------+ | | //es5的风格 | | StoreMixin | msg(EventEmitter) \|/ |+------------------------+ || React App |-----|+------------------------+| &lt;Layout&gt; || &lt;SearchForm/&gt; || &lt;Toolbar/&gt; || &lt;DataGrid/&gt; || &lt;/Layout&gt; |+------------------------+ 一个应用只有一个Store，单根数据源，单向数据流动，数据沉淀在顶层。且通过PureRenderMix可以获取更好的性能。简直就是为React私人定制一般。 于是，顺其自然的写了iflux去更好的粘合React和immutable。 整体思路： React只承担view应该承担的事情（1. 资料呈现 2. 用户交互） 不处理任何的业务逻辑，就是根据数据去渲染dom即可，这样view可以做的很轻。 应用的全部数据沉淀在一个Store中，当全部数据在顶层时，很多事情都变得简单，因为获取数据变得十分廉价。无论是校验和对数据的转换控制都变得非常简单。 React只是取数据渲染，其他的比如状态的变化全部通过事件pubsub通知appstore去更新数据。如果状态不会影响其他组件的级联变化可以放在组件内部消化掉。 所有的ajax封装在webapi模块中，全部promise化。回调回来通过cursor更新store, cursor更新store， store通知React去rerender。 区分View component 和 pure component。 如何使用?123456mkdir hellocd hellonpm initnpm install react immutable iflux --savenpm install babel-loader --save-dev 12345678910111213➜ iflux-demo tree -L 3.├── apps #we like django&apos;s app-style│ └── index #app-name│ ├── index.js #viewcontainer component│ ├── component #collect of dump components│ ├── store.js #immutable store│ └── webapi.js #fetch remote resource├── node_modules├── package.json└── webpack.config.js5 directories, 4 files 例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596//webapi.jsexport const fetchGithub = (name) =&gt; &#123; return fetch(`http://github.com/$&#123;name&#125;`)&#125;;export default &#123; fetchGithub&#125;;//store.jsimport &#123; Store, msg &#125; from 'iflux';import &#123; fromJS &#125; from 'immutable';import &#123; fetchGithub &#125; from './webapi';const appStore = Store(&#123; name: '', githubInfo: &#123;&#125;&#125;);exports default appStore;//when use immutable's cursor to update store//react's view will auto re-rendermsg.on('updateName', (name) =&gt; &#123; appStore.cursor().set('name', name);&#125;);msg.on('submit', async () =&gt; &#123; const data = await fetchGithub(name); appStore.cursor.set('githubInfo', fromJS(data));&#125;);//index.js//es5的样式import React from 'react';import &#123;msg, mixins&#125; from 'iflux';import appStore from './store';const &#123;StoreMixin&#125; = mixins;const IfluxApp = React.createClass(&#123; //自动将Store中的data混入到state mixins: [StoreMixin(appStore)], render() &#123; var store = appStore.data(); return ( &lt;div&gt; &lt;form onSubmit=&#123;this._submit&#125;&gt; &lt;input name="name" onChange=&#123;this._handleChange&#125;/&gt; &lt;/form&gt; &lt;div&gt; &#123;store.get('githubInfo')&#125; &lt;/div&gt; &lt;/div&gt; ); &#125;, _handleChange(e) &#123; msg.emit('updateName', e.target.value); &#125;, _submit() &#123; msg.emit('getGithubInfo'); &#125;&#125;);//es6的样式import React from 'react';import &#123; msg, connectToStore &#125; from 'iflux';import appStore from './store';class IfluxApp extends React.Component &#123; render() &#123; const &#123;store&#125; = this.props; return ( &lt;div&gt; &lt;form onSubmit=&#123;this._submit&#125;&gt; &lt;input name="name" onChange=&#123;this._handleChange&#125;/&gt; &lt;/form&gt; &lt;div&gt; &#123;store.get('githubInfo')&#125; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125;export default connectToStore(appStore)(IfluxApp);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ReactNative学习-state与props介绍与比较]]></title>
      <url>%2F2017%2F02%2F28%2FReactNative%E5%AD%A6%E4%B9%A0-state%E4%B8%8Eprops%E4%BB%8B%E7%BB%8D%E4%B8%8E%E6%AF%94%E8%BE%83%2F</url>
      <content type="text"><![CDATA[State state的作用 state是React中组件的一个对象.React把用户界面当做是状态机,想象它有不同的状态然后渲染这些状态,可以轻松让用户界面与数据保持一致. React中,更新组件的state,会导致重新渲染用户界面(不要操作DOM).简单来说,就是用户界面会随着state变化而变化. state工作原理 常用的通知React数据变化的方法是调用setState(data,callback).这个方法会合并data到this.state,并重新渲染组件.渲染完成后,调用可选的callback回调.大部分情况不需要提供callback,因为React会负责吧界面更新到最新状态. 那些组件应该有state? 大部分组件的工作应该是从props里取数据并渲染出来.但是,有时需要对用户输入,服务器请求或者时间变化等作出响应,这时才需要state. 组件应该尽可能的无状态化,这样能隔离state,把它放到最合理的地方(Redux做的就是这个事情?),也能减少冗余并易于解释程序运作过程. 常用的模式就是创建多个只负责渲染数据的无状态(stateless)组件,在他们的上层创建一个有状态(stateful)组件并把它的状态通过props传给子级.有状态的组件封装了所有的用户交互逻辑,而这些无状态组件只负责声明式地渲染数据. 哪些应该作为state? state应该包括那些可能被组件的事件处理器改变并触发用户界面更新的数据.这中数据一般很小且能被JSON序列化.当创建一个状态化的组件的时候,应该保持数据的精简,然后存入this.state.在render()中在根据state来计算需要的其他数据.因为如果在state里添加冗余数据或计算所得数据,经常需要手动保持数据同步. 那些不应该作为state? this.state应该仅包括能表示用户界面状态所需要的最少数据.因此,不应该包括: 计算所得数据: React组件:在render()里使用props和state来创建它. 基于props的重复数据:尽可能保持用props来做作为唯一的数据来源.把props保存到state中的有效的场景是需要知道它以前的值得时候,因为未来的props可能会变化. props props的作用 组件中的props是一种父级向子级传递数据的方式. 复合组件 123456789101112131415161718192021222324252627282930313233var Avatar = React.createClass(&#123; 2 render: function() &#123; 3 return ( 4 &lt;div&gt; 5 &lt;ProfilePic username=&#123;this.props.username&#125; /&gt; 6 &lt;ProfileLink username=&#123;this.props.username&#125; /&gt; 7 &lt;/div&gt; 8 ); 9 &#125;10 &#125;);11 12 var ProfilePic = React.createClass(&#123;13 render: function() &#123;14 return (15 &lt;img src=&#123;&apos;http://graph.facebook.com/&apos; + this.props.username + &apos;/picture&apos;&#125; /&gt;16 );17 &#125;18 &#125;);19 20 var ProfileLink = React.createClass(&#123;21 render: function() &#123;22 return (23 &lt;a href=&#123;&apos;http://www.facebook.com/&apos; + this.props.username&#125;&gt;24 &#123;this.props.username&#125;25 &lt;/a&gt;26 );27 &#125;28 &#125;);29 30 React.render(31 &lt;Avatar username=&quot;pwh&quot; /&gt;,32 document.getElementById(&apos;example&apos;)33 );]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac环境更改shell自定义终端-oh my zsh安装及配置]]></title>
      <url>%2F2017%2F02%2F25%2FMac%E7%8E%AF%E5%A2%83%E6%9B%B4%E6%94%B9shell%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%88%E7%AB%AF-oh-my-zsh%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[安装oh my zsh:1.克隆这个项目到本地（根路径 ~） 1git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh 2.创建一个zsh的配置文件 注意:如果你已经有一个~/.zshrc文件的话，建议你先做备份。 备份配置文件 1cp ~/.zshrc ~/.zshrc.orig 然后开始创建zsh的配置文件 1cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc 3.查看系统内置了几种shell 1cat /etc/shells 4.设置zsh为你的默认的shell 1chsh -s /bin/zsh 5.重启终端 更改zsh主题:1.编辑 ~/.zshrc 2.修改主题Ps：主题文件在 ~/.oh-my-zsh/themes 目录 1ZSH_THEME=&quot;ys&quot;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac环境使用DigitalOcean租用VPS，部署Docker容器+SS搭建专属梯子]]></title>
      <url>%2F2017%2F02%2F21%2FMac%E7%8E%AF%E5%A2%83%E4%BD%BF%E7%94%A8DigitalOcean%E7%A7%9F%E7%94%A8VPS%EF%BC%8C%E9%83%A8%E7%BD%B2Docker%E5%AE%B9%E5%99%A8-SS%E6%90%AD%E5%BB%BA%E4%B8%93%E5%B1%9E%E6%A2%AF%E5%AD%90%2F</url>
      <content type="text"><![CDATA[技术在于折腾。 一、DigitalOcean官网注册https://cloud.digitalocean.com/ps：注册费用$5，现在还送$10，一共$15,如果选用最便宜的服务器，可以使用3个月。二、创建虚拟服务器 三、选择服务器 系统默认是乌班图，喜欢CoreOS、CentOS可以自行选择 价钱是每月的使用费以及设备的配置，如果平时上网话，5刀的足以 线路使用纽约、旧金山都可以，建议使用旧金山的四、选择连接方式，建议使用ssh连接(安全) ps：关于配置ssh可以在settings里面找到。 生成ssh，可以参考github官方生成文档：https://help.github.com/articles/connecting-to-github-with-ssh/ 查看ssh,可以通过查找文件输入 ~/.ssh的方式具体查看公钥1cat ~/.ssh/id_rsa.pub 再把查看的公钥粘贴至对话框 四、连接服务器 连接服务器，生成的IP地址 1ssh root@xxx.xxx.xxx.xxx 部署docker容器 1apt install docker.io 拉取shadowsocks 仓库 1docker pull oddrationale/docker-shadowsocks 设置仓库的端口、密码、及加密方式ps：xxxxxx 是你要设置的密码1984 是你的端口号 1docker run -d -p 1984:1984 oddrationale/docker-shadowsocks -s 0.0.0.0 -p 1984 -k xxxxxx -m aes-256-cfb 查看docker 列表ps：如果出现up就表明部署成功 1docker ps 五、下载ss客户端（shadowsocks），并添加。GitHub官方提供下载dmg：https://github.com/shadowsocks/shadowsocks-iOS/releases 安装后配置服务器，打开服务器设置，并添加服务器。 把创建的服务器Ip、端口号及创建的加密方式密码填入即可ps：默认端口号填写的1984加密方式选择aes-256-cfb]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Node之Package.json文件参数解析]]></title>
      <url>%2F2017%2F02%2F13%2FNode%E4%B9%8Bpackage-json%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%2F</url>
      <content type="text"><![CDATA[参考JavaScript 标准参考教程（alpha）http://javascript.ruanyifeng.com/nodejs/packagejson.html#toc0 概述 package.json在Node项目中用于描述项目的一些基本信息，以及依赖库的配置，一般每一个Node项目的根目录下都有一个package.json文件。 在项目的根目录中package.json文件可以手工编写，也可以使用npm init命令自动生成，其内容是一个Json对象。 1npm init 基本结构如下： 12345678910111213141516171819&#123; &quot;name&quot;: &quot;package&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;dependencies&quot;: &#123; &quot;babel-cli&quot;: &quot;^6.23.0&quot;, &quot;babel-preset-env&quot;: &quot;^1.1.8&quot;, &quot;hexo&quot;: &quot;^3.2.0&quot;, &quot;immutable&quot;: &quot;^3.8.1&quot;, &quot;iflux&quot;: &quot;^1.2.16&quot; &#125;, &quot;devDependencies&quot;: &#123;&#125;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;&#125; scripts字段参考文献npm scripts 使用指南 By阮一峰http://www.ruanyifeng.com/blog/2016/10/npm_scripts.htmlscripts的每一个属性，对应一段脚本。是指定了运行脚本命令的npm命令行缩写，比如start 属性指定了运行npm run start时，所要执行的命令。 123npm run start# 等同于执行node index.js 下面的设置指定了npm run preinstall、npm run postinstall、npm run start、npm run test时，所要执行的命令。 123456&quot;scripts&quot;: &#123; &quot;preinstall&quot;: &quot;echo here it comes!&quot;, &quot;postinstall&quot;: &quot;echo there it goes!&quot;, &quot;start&quot;: &quot;node index.js&quot;, &quot;test&quot;: &quot;tap test/*.js&quot;&#125; dependencies字段，devDependencies字段dependencies字段指定了项目运行所依赖的模块，devDependencies指定项目开发所需要的模块。 它们都指向一个对象。该对象的各个成员，分别由模块名和对应的版本要求组成，表示依赖的模块及其版本范围。 123456&#123; &quot;devDependencies&quot;: &#123; &quot;browserify&quot;: &quot;~13.0.0&quot;, &quot;karma-browserify&quot;: &quot;~5.0.1&quot; &#125;&#125; 指定版本：比如1.2.2，遵循“大版本.次要版本.小版本”的格式规定，安装时只安装指定版本。 波浪号（tilde）+指定版本：比如~1.2.2，表示安装1.2.x的最新版本（不低于1.2.2），但是不安装1.3.x，也就是说安装时不改变大版本号和次要版本号。 插入号（caret）+指定版本：比如ˆ1.2.2，表示安装1.x.x的最新版本（不低于1.2.2），但是不安装2.x.x，也就是说安装时不改变大版本号。需要注意的是，如果大版本号为0，则插入号的行为与波浪号相同，这是因为此时处于开发阶段，即使是次要版本号变动，也可能带来程序的不兼容。 latest：安装最新版本。 安装所需要的模块吗，直接使用npm install命令。 1npm install XXXX 如果一个模块不在package.json文件之中，可以单独安装这个模块，并使用相应的参数，将其写入package.json文件之中。 123npm install express --savenpm install express --save-dev 上面代码表示单独安装express模块，–save 表示将该模块写入dependencies属性，–save-dev 表示将该模块写入devDependencies属性。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ReactNative学习-React技术栈全家桶]]></title>
      <url>%2F2016%2F12%2F24%2FReactNative%E5%AD%A6%E4%B9%A0-React-js%E5%85%A8%E5%AE%B6%E6%A1%B6%2F</url>
      <content type="text"><![CDATA[React 技术栈系列教程http://www.ruanyifeng.com/blog/2016/09/react-technology-stack.html React.js 入门教程http://www.ruanyifeng.com/blog/2015/03/react.html ECMAScript 6 入门http://es6.ruanyifeng.com/#docs/style ReactNative 中文网http://reactnative.cn Immutable.js 官方文档http://facebook.github.io/immutable-js/ Immutable 详解及 React 中实践https://zhuanlan.zhihu.com/p/20295971?columnSlug=purerender Flux 架构入门教程http://www.ruanyifeng.com/blog/2016/01/flux.html Flux 架构官方英文文档https://facebook.github.io/flux/docs/overview.html#content Redux 入门教程（一）：基本用法http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html Redux 入门教程（二）：中间件（middleware）与异步操作http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_two_async_operations.html Redux 入门教程（三）：React-Redux 的用法http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_three_react-redux.html Redux.js 官方英文文档http://redux.js.org Redux.js GitHub中文文档http://cn.redux.js.org/docs/react-redux/api.html Flex 布局教程：语法篇http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool 浅谈 React、Flux 与 Reduxhttp://www.tuicool.com/articles/3AFJNbj 怎样理顺react，flux，redux这些概念的关系，开发中有必要使用它们吗?https://www.zhihu.com/question/47686258/answer/107209140 DEMO文章：这段时间看了下Redux，写自己对它的感觉。http://react-china.org/t/redux/2687 基于 react + react-router + redux + webpack + ES6/7 + less 的完整项目https://github.com/bailicangdu/react-pxq 基于webpack + react + react-router + redux + less + flex.css + ES6 的React版cnode社区http://react-china.org/t/webpack-react-react-router-redux-less-flex-css-es6-react-cnode/6332 概述大前端的时代来了，还不要准备好么？ 做React需要会什么？react的功能其实很单一，主要负责渲染的功能，现有的框架，比如angular是一个大而全的框架，用了angular几乎就不需要用其他工具辅助配合，但是react不一样，他只负责ui渲染，想要做好一个项目，往往需要其他库和工具的配合，比如用redux来管理数据，react-router管理路由，react已经全面拥抱es6，所以es6也得掌握，webpack就算是不会配置也要会用，要想提高性能，需要按需加载，immutable.js也得用上，还有单元测试等。 React 是什么用脚本进行DOM操作的代价很昂贵。有个贴切的比喻，把DOM和JavaScript各自想象为一个岛屿，它们之间用收费桥梁连接，js每次访问DOM，都要途径这座桥，并交纳“过桥费”,访问DOM的次数越多，费用也就越高。 因此，推荐的做法是尽量减少过桥的次数，努力待在ECMAScript岛上。因为这个原因react的虚拟dom就显得难能可贵了，它创造了虚拟dom并且将它们储存起来，每当状态发生变化的时候就会创造新的虚拟节点和以前的进行对比，让变化的部分进行渲染。整个过程没有对dom进行获取和操作，只有一个渲染的过程，所以react说是一个ui框架。 React的组件化react的一个组件很明显的由dom视图和state数据组成，两个部分泾渭分明。state是数据中心，它的状态决定着视图的状态。这时候发现似乎和我们一直推崇的MVC开发模式有点区别，没了Controller控制器，那用户交互怎么处理，数据变化谁来管理？然而这并不是react所要关心的事情，它只负责ui的渲染。与其他框架监听数据动态改变dom不同，react采用setState来控制视图的更新。setState会自动调用render函数，触发视图的重新渲染，如果仅仅只是state数据的变化而没有调用setState，并不会触发更新。 组件就是拥有独立功能的视图模块，许多小的组件组成一个大的组件，整个页面就是由一个个组件组合而成。它的好处是利于重复利用和维护。 React的 Diff算法react的diff算法用在什么地方呢？当组件更新的时候，react会创建一个新的虚拟dom树并且会和之前储存的dom树进行比较，这个比较多过程就用到了diff算法，所以组件初始化的时候是用不到的。react提出了一种假设，相同的节点具有类似的结构，而不同的节点具有不同的结构。在这种假设之上进行逐层的比较，如果发现对应的节点是不同的，那就直接删除旧的节点以及它所包含的所有子节点然后替换成新的节点。如果是相同的节点，则只进行属性的更改。 对于列表的diff算法稍有不同，因为列表通常具有相同的结构，在对列表节点进行删除，插入，排序的时候，单个节点的整体操作远比一个个对比一个个替换要好得多，所以在创建列表的时候需要设置key值，这样react才能分清谁是谁。当然不写key值也可以，但这样通常会报出警告，通知我们加上key值以提高react的性能。 React组件是怎么来的组件的创造方法为React.createClass() ——创造一个类，react系统内部设计了一套类系统，利用它来创造react组件。但这并不是必须的，我们还可以用es6的class类来创造组件,这也是Facebook官方推荐的写法。 这两种写法实现的功能一样但是原理却是不同，es6的class类可以看作是构造函数的一个语法糖，可以把它当成构造函数来看，extends实现了类之间的继承 —— 定义一个类Main 继承React.Component所有的属性和方法，组件的生命周期函数就是从这来的。constructor是构造器，在实例化对象时调用，super调用了父类的constructor创造了父类的实例对象this，然后用子类的构造函数进行修改。这和es5的原型继承是不同的，原型继承是先创造一个实例化对象this，然后再继承父级的原型方法。了解了这些之后我们在看组件的时候就清楚很多。 当我们使用组件&lt; Main /&gt;时，其实是对Main类的实例化——new Main，只不过react对这个过程进行了封装，让它看起来更像是一个标签。 有三点值得注意：1、定义类名字的首字母必须大写 2、因为class变成了关键字，类选择器需要用className来代替。 3、类和模块内部默认使用严格模式，所以不需要用use strict指定运行模式。 组件的生命周期 组件在初始化时会触发5个钩子函数： 1、getDefaultProps() 设置默认的props，也可以用dufaultProps设置组件的默认属性。 2、getInitialState() 在使用es6的class语法时是没有这个钩子函数的，可以直接在constructor中定义this.state。此时可以访问this.props。 3、componentWillMount() 组件初始化时只调用，以后组件更新不调用，整个生命周期只调用一次，此时可以修改state。 4、 render() react最重要的步骤，创建虚拟dom，进行diff算法，更新dom树都在此进行。此时就不能更改state了。 5、componentDidMount() 组件渲染之后调用，可以通过this.getDOMNode()获取和操作dom节点，只调用一次。 在更新时也会触发5个钩子函数： 6、componentWillReceivePorps(nextProps) 组件初始化时不调用，组件接受新的props时调用。 7、shouldComponentUpdate(nextProps, nextState) react性能优化非常重要的一环。组件接受新的state或者props时调用，我们可以设置在此对比前后两个props和state是否相同，如果相同则返回false阻止更新，因为相同的属性状态一定会生成相同的dom树，这样就不需要创造新的dom树和旧的dom树进行diff算法对比，节省大量性能，尤其是在dom结构复杂的时候。不过调用this.forceUpdate会跳过此步骤。 8、componentWillUpdata(nextProps, nextState) 组件初始化时不调用，只有在组件将要更新时才调用，此时可以修改state 9、render() 不多说 10、componentDidUpdate() 组件初始化时不调用，组件更新完成后调用，此时可以获取dom节点。 还有一个卸载钩子函数 11、componentWillUnmount() 组件将要卸载时调用，一些事件监听和定时器需要在此时清除。 以上可以看出来react总共有10个周期函数（render重复一次），这个10个函数可以满足我们所有对组件操作的需求，利用的好可以提高开发效率和组件性能。 React-Router路由Router就是React的一个组件，它并不会被渲染，只是一个创建内部路由规则的配置对象，根据匹配的路由地址展现相应的组件。Route则对路由地址和组件进行绑定，Route具有嵌套功能，表示路由地址的包涵关系，这和组件之间的嵌套并没有直接联系。Route可以向绑定的组件传递7个属性：children，history，location，params，route，routeParams，routes，每个属性都包涵路由的相关的信息。比较常用的有children（以路由的包涵关系为区分的组件），location（包括地址，参数，地址切换方式，key值，hash值）。react-router提供Link标签，这只是对a标签的封装，值得注意的是，点击链接进行的跳转并不是默认的方式，react-router阻止了a标签的默认行为并用pushState进行hash值的转变。切换页面的过程是在点击Link标签或者后退前进按钮时，会先发生url地址的转变，Router监听到地址的改变根据Route的path属性匹配到对应的组件，将state值改成对应的组件并调用setState触发render函数重新渲染dom。 当页面比较多时，项目就会变得越来越大，尤其对于单页面应用来说，初次渲染的速度就会很慢，这时候就需要按需加载，只有切换到页面的时候才去加载对应的js文件。react配合webpack进行按需加载的方法很简单，Route的component改为getComponent，组件用require.ensure的方式获取，并在webpack中配置chunkFilename。 1234567891011121314151617181920212223242526272829const chooseProducts = (location, cb) =&gt; &#123; require.ensure([], require =&gt; &#123; cb(null, require('../Component/chooseProducts').default) &#125;,'chooseProducts')&#125;const helpCenter = (location, cb) =&gt; &#123; require.ensure([], require =&gt; &#123; cb(null, require('../Component/helpCenter').default) &#125;,'helpCenter')&#125;const saleRecord = (location, cb) =&gt; &#123; require.ensure([], require =&gt; &#123; cb(null, require('../Component/saleRecord').default) &#125;,'saleRecord')&#125;const RouteConfig = ( &lt;Router history=&#123;history&#125;&gt; &lt;Route path="/" component=&#123;Roots&#125;&gt; &lt;IndexRoute component=&#123;index&#125; /&gt;//首页 &lt;Route path="index" component=&#123;index&#125; /&gt; &lt;Route path="helpCenter" getComponent=&#123;helpCenter&#125; /&gt;//帮助中心 &lt;Route path="saleRecord" getComponent=&#123;saleRecord&#125; /&gt;//销售记录 &lt;Redirect from='*' to='/' /&gt; &lt;/Route&gt; &lt;/Router&gt;); 组件之间的通信react推崇的是单向数据流，自上而下进行数据的传递，但是由下而上或者不在一条数据流上的组件之间的通信就会变的复杂。解决通信问题的方法很多，如果只是父子级关系，父级可以将一个回调函数当作属性传递给子级，子级可以直接调用函数从而和父级通信。 组件层级嵌套到比较深，可以使用上下文getChildContext来传递信息，这样在不需要将函数一层层往下传，任何一层的子级都可以通过this.context直接访问。 兄弟关系的组件之间无法直接通信，它们只能利用同一层的上级作为中转站。而如果兄弟组件都是最高层的组件，为了能够让它们进行通信，必须在它们外层再套一层组件，这个外层的组件起着保存数据，传递信息的作用，这其实就是redux所做的事情。 组件之间的信息还可以通过全局事件来传递。不同页面可以通过参数传递数据，下个页面可以用location.param来获取。其实react本身很简单，难的在于如何优雅高效的实现组件之间数据的交流。 Redux首先，redux并不是必须的，它的作用相当于在顶层组件之上又加了一个组件，作用是进行逻辑运算、储存数据和实现组件尤其是顶层组件的通信。如果组件之间的交流不多，逻辑不复杂，只是单纯的进行视图的渲染，这时候用回调，context就行，没必要用redux，用了反而影响开发速度。但是如果组件交流特别频繁，逻辑很复杂，那redux的优势就特别明显了。我第一次做react项目的时候并没有用redux，所有的逻辑都是在组件内部实现，当时为了实现一个逻辑比较复杂的购物车，洋洋洒洒居然写了800多行代码，回头一看我自己都不知道写的是啥，画面太感人。 先简单说一下redux和react是怎么配合的。react-redux提供了connect和Provider两个好基友，它们一个将组件与redux关联起来，一个将store传给组件。组件通过dispatch发出action，store根据action的type属性调用对应的reducer并传入state和这个action，reducer对state进行处理并返回一个新的state放入store，connect监听到store发生变化，调用setState更新组件，此时组件的props也就跟着变化。 流程是这个样子的： 值得注意的是connect，Provider，mapStateToProps,mapDispatchToProps是react-redux提供的，redux本身和react没有半毛钱关系，它只是数据处理中心，没有和react产生任何耦合，是react-redux让它们联系在一起。 接下来具体分析一下，redux以及react-redux到底是怎么实现的。先上一张图 明显比第一张要复杂，其实两张图说的是同一件事。从上而下慢慢分析： 先说说redux：redux主要由三部分组成：store，reducer，action。store是一个对象，它有四个主要的方法： 1、dispatch: 用于action的分发——在createStore中可以用middleware中间件对dispatch进行改造，比如当action传入dispatch会立即触发reducer，有些时候我们不希望它立即触发，而是等待异步操作完成之后再触发，这时候用redux-thunk对dispatch进行改造，以前只能传入一个对象，改造完成后可以传入一个函数，在这个函数里我们手动dispatch一个action对象，这个过程是可控的，就实现了异步。 2、subscribe： 监听state的变化——这个函数在store调用dispatch时会注册一个listener监听state变化，当我们需要知道state是否变化时可以调用，它返回一个函数，调用这个返回的函数可以注销监听。let unsubscribe = store.subscribe(() =&gt; {console.log(‘state发生了变化’)}) 3、getState： 获取store中的state——当我们用action触发reducer改变了state时，需要再拿到新的state里的数据，毕竟数据才是我们想要的。getState主要在两个地方需要用到，一是在dispatch拿到action后store需要用它来获取state里的数据，并把这个数据传给reducer，这个过程是自动执行的，二是在我们利用subscribe监听到state发生变化后调用它来获取新的state数据，如果做到这一步，说明我们已经成功了。 4、replaceReducer: 替换reducer，改变state修改的逻辑。 store可以通过createStore()方法创建，接受三个参数，经过combineReducers合并的reducer和state的初始状态以及改变dispatch的中间件，后两个参数并不是必须的。store的主要作用是将action和reducer联系起来并改变state。 action: action是一个对象，其中type属性是必须的，同时可以传入一些数据。action可以用actionCreactor进行创造。dispatch就是把action对象发送出去。 reducer: reducer是一个函数，它接受一个state和一个action，根据action的type返回一个新的state。根据业务逻辑可以分为很多个reducer，然后通过combineReducers将它们合并，state树中有很多对象，每个state对象对应一个reducer，state对象的名字可以在合并时定义。 像这个样子：12345const reducer = combineReducers(&#123; a: doSomethingWithA, b: processB, c: c&#125;) combineReducers: 其实它也是一个reducer，它接受整个state和一个action，然后将整个state拆分发送给对应的reducer进行处理，所有的reducer会收到相同的action，不过它们会根据action的type进行判断，有这个type就进行处理然后返回新的state，没有就返回默认值，然后这些分散的state又会整合在一起返回一个新的state树。 接下来分析一下整体的流程，首先调用store.dispatch将action作为参数传入，同时用getState获取当前的状态树state并注册subscribe的listener监听state变化，再调用combineReducers并将获取的state和action传入。combineReducers会将传入的state和action传给所有reducer，reducer会根据state的key值获取与自己对应的state，并根据action的type返回新的state，触发state树的更新，我们调用subscribe监听到state发生变化后用getState获取新的state数据。 redux的state和react的state两者完全没有关系，除了名字一样。 上面分析了redux的主要功能，那么react-redux到底做了什么？ React-Redux如果只使用redux，那么流程是这样的： component –&gt; dispatch(action) –&gt; reducer –&gt; subscribe –&gt; getState –&gt; component 用了react-redux之后流程是这样的： component –&gt; actionCreator(data) –&gt; reducer –&gt; component store的三大功能：dispatch，subscribe，getState都不需要手动来写了。react-redux帮我们做了这些，同时它提供了两个好基友Provider和connect。 Provider是一个组件，它接受store作为props，然后通过context往下传，这样react中任何组件都可以通过contex获取store。也就意味着我们可以在任何一个组件里利用dispatch(action)来触发reducer改变state，并用subscribe监听state的变化，然后用getState获取变化后的值。但是并不推荐这样做，它会让数据流变的混乱，过度的耦合也会影响组件的复用，维护起来也更麻烦。 connect –connect(mapStateToProps, mapDispatchToProps, mergeProps, options)是一个函数，它接受四个参数并且再返回一个函数–wrapWithConnect，wrapWithConnect接受一个组件作为参数wrapWithConnect(component)，它内部定义一个新组件Connect(容器组件)并将传入的组件(ui组件)作为Connect的子组件然后return出去。 所以它的完整写法是这样的：connect(mapStateToProps, mapDispatchToProps, mergeProps, options)(component) mapStateToProps(state, [ownProps])： mapStateToProps 接受两个参数，store的state和自定义的props，并返回一个新的对象，这个对象会作为props的一部分传入ui组件。我们可以根据组件所需要的数据自定义返回一个对象。ownProps的变化也会触发mapStateToProps 123function mapStateToProps(state) &#123; return &#123; todos: state.todos &#125;;&#125; mapDispatchToProps(dispatch, [ownProps])： mapDispatchToProps如果是对象，那么会和store绑定作为props的一部分传入ui组件。如果是个函数，它接受两个参数，bindActionCreators会将action和dispatch绑定并返回一个对象，这个对象会和ownProps一起作为props的一部分传入ui组件。所以不论mapDispatchToProps是对象还是函数，它最终都会返回一个对象，如果是函数，这个对象的key值是可以自定义的 123456function mapDispatchToProps(dispatch) &#123; return &#123; todoActions: bindActionCreators(todoActionCreators, dispatch), counterActions: bindActionCreators(counterActionCreators, dispatch) &#125;;&#125; mapDispatchToProps返回的对象其属性其实就是一个个actionCreator，因为已经和dispatch绑定，所以当调用actionCreator时会立即发送action，而不用手动dispatch。ownProps的变化也会触发mapDispatchToProps。 mergeProps(stateProps, dispatchProps, ownProps)： 将mapStateToProps() 与 mapDispatchToProps()返回的对象和组件自身的props合并成新的props并传入组件。默认返回 Object.assign({}, ownProps, stateProps, dispatchProps) 的结果。 options： pure = true 表示Connect容器组件将在shouldComponentUpdate中对store的state和ownProps进行浅对比，判断是否发生变化，优化性能。为false则不对比。 其实connect函数并没有做什么，大部分的逻辑都是在它返回的wrapWithConnect函数内实现的，确切的说是在wrapWithConnect内定义的Connect组件里实现的。 下面是一个完整的 react –&gt; redux –&gt; react 流程：一、Provider组件接受redux的store作为props，然后通过context往下传。 二、connect函数在初始化的时候会将mapDispatchToProps对象绑定到store，如果mapDispatchToProps是函数则在Connect组件获得store后，根据传入的store.dispatch和action通过bindActionCreators进行绑定，再将返回的对象绑定到store，connect函数会返回一个wrapWithConnect函数，同时wrapWithConnect会被调用且传入一个ui组件，wrapWithConnect内部使用class Connect extends Component定义了一个Connect组件，传入的ui组件就是Connect的子组件，然后Connect组件会通过context获得store，并通过store.getState获得完整的state对象，将state传入mapStateToProps返回stateProps对象、mapDispatchToProps对象或mapDispatchToProps函数会返回一个dispatchProps对象，stateProps、dispatchProps以及Connect组件的props三者通过Object.assign()，或者mergeProps合并为props传入ui组件。然后在ComponentDidMount中调用store.subscribe，注册了一个回调函数handleChange监听state的变化。 三、此时ui组件就可以在props中找到actionCreator，当我们调用actionCreator时会自动调用dispatch，在dispatch中会调用getState获取整个state，同时注册一个listener监听state的变化，store将获得的state和action传给combineReducers，combineReducers会将state依据state的key值分别传给子reducer，并将action传给全部子reducer，reducer会被依次执行进行action.type的判断，如果有则返回一个新的state，如果没有则返回默认。combineReducers再次将子reducer返回的单个state进行合并成一个新的完整的state。此时state发生了变化。dispatch在state返回新的值之后会调用所有注册的listener函数其中包括handleChange函数，handleChange函数内部首先调用getState获取新的state值并对新旧两个state进行浅对比，如果相同直接return，如果不同则调用mapStateToProps获取stateProps并将新旧两个stateProps进行浅对比，如果相同，直接return结束，不进行后续操作。如果不相同则调用this.setState()触发Connect组件的更新，传入ui组件，触发ui组件的更新，此时ui组件获得新的props，react –&gt; redux –&gt; react 的一次流程结束。 上面的有点复杂，简化版的流程是： 一、Provider组件接受redux的store作为props，然后通过context往下传。 二、connect函数收到Provider传出的store，然后接受三个参数mapStateToProps，mapDispatchToProps和组件，并将state和actionCreator以props传入组件，这时组件就可以调用actionCreator函数来触发reducer函数返回新的state，connect监听到state变化调用setState更新组件并将新的state传入组件。 connect可以写的非常简洁，mapStateToProps，mapDispatchToProps只不过是传入的回调函数，connect函数在必要的时候会调用它们，名字不是固定的，甚至可以不写名字。 简化版本：1connect(state =&gt; state, action)(Component); 项目搭建上面说了react，react-router和redux的知识点。但是怎么样将它们整合起来，搭建一个完整的项目。 1、先引用 react.js，redux，react-router 等基本文件，建议用npm安装，直接在文件中引用。 2、从 react.js，redux，react-router 中引入所需要的对象和方法。12345import React, &#123;Component, PropTypes&#125; from 'react';import ReactDOM, &#123;render&#125; from 'react-dom';import &#123;Provider, connect&#125; from 'react-redux';import &#123;createStore, combineReducers, applyMiddleware&#125; from 'redux';import &#123; Router, Route, Redirect, IndexRoute, browserHistory, hashHistory &#125; from 'react-router'; 3、根据需求创建顶层ui组件，每个顶层ui组件对应一个页面。 4、创建actionCreators和reducers，并用combineReducers将所有的reducer合并成一个大的reduer。利用createStore创建store并引入combineReducers和applyMiddleware。 5、利用connect将actionCreator，reuder和顶层的ui组件进行关联并返回一个新的组件。 6、利用connect返回的新的组件配合react-router进行路由的部署，返回一个路由组件Router。 7、将Router放入最顶层组件Provider，引入store作为Provider的属性。 8、调用render渲染Provider组件且放入页面的标签中。 可以看到顶层的ui组件其实被套了四层组件，Provider，Router，Route，Connect，这四个组件并不会在视图上改变react，它们只是功能性的。 通常我们在顶层的ui组件打印props时可以看到一堆属性： 上图的顶层ui组件属性总共有18个，如果刚刚接触react，可能对这些属性怎么来的感到困惑，其实这些属性来自五个地方： 组件自定义属性1个，actionCreator返回的对象6个，reducer返回的state4个，Connect组件属性0个，以及Router注入的属性7个。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ReactNative学习-MAC集成环境]]></title>
      <url>%2F2016%2F12%2F08%2FReactNative%E5%AD%A6%E4%B9%A0-MAC%E9%9B%86%E6%88%90%E7%8E%AF%E5%A2%83%2F</url>
      <content type="text"><![CDATA[官网有更详细的集成步骤，这里只是根据个人需求写出简单实用的集成步骤。 1.配置环境按照HomeBrew1/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 安装Node.js1brew install node 替换npm仓库镜像源123npm config set registry https://registry.npm.taobao.org --globalnpm config set disturl https://npm.taobao.org/dist --global 安装WatchmanWatchman是由Facebook提供的监视文件系统变更的工具。安装此工具可以提高开发时的性能 1brew install watchman 2.安装工具包安装RN命令行工具包1npm install -g yarn react-native-cli 遇到EACCES: permission denied权限报错，需要修复/usr/local目录的所有权： 1sudo chown -R `whoami` /usr/local 3.创建React Native测试项目主要是需要 cd 到对应文件目录，再init， ”testProject“ 名字是自定义的 1react-native init testProject 如果报错, 无法创建. 尝试使用使用下面的命令更新brew及对应的工具123brew updatebrew upgrade 打开项目, 找到iOS文件夹中的工程文件运行即可]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift学习-Swift3.0已出坑，适配iOS10,项目迁移Swift3.0问题总结。]]></title>
      <url>%2F2016%2F10%2F15%2FSwift%E5%AD%A6%E4%B9%A0-Swift3-0%E5%B7%B2%E5%87%BA%E5%9D%91%EF%BC%8C%E9%80%82%E9%85%8DiOS10-%E9%A1%B9%E7%9B%AE%E8%BF%81%E7%A7%BBSwift3-0%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E3%80%82%2F</url>
      <content type="text"><![CDATA[前言 Swift项目,为适配iOS10,无奈只能更新Xcode 8 ,可是发现一入3.0深似海,从此幸福是路人.于是边摸索边修改,在节前的完成代码迁移.节后在完成手头工作后,整理思路,把Swift3.0迁移的心得分享大家.废话不多说分享下心得: 1、代码篇:(一定要做好备份!!!) 1&gt;升级Xcode8正式版(8A218a). 2&gt;使用系统自带的桥接工具.(原装的就是好,直接打开2.2项目也会提醒-&gt;步骤:3)Edit &gt; Convert &gt; To Current Swift Syntax.. 3&gt;不用说就是为3.0来的,选择Swift3. 4&gt;上面的框架就不用选了,只选择.app的.(这个是检测代码,不然你会哭的) 5&gt;检测完后.在左边的选择页中选择好要转移的代码,左边的代码是Swift3.0代码,右侧代码时swift2.2代码-&gt;点Save. 2、第三方框架篇:(使用的cocoapods管理的第三方框架) 1&gt;发现框架报错.(不要怕,按照错误一样一样来)* 问题1:–.第三方框架版本问题,”Use Legacy Swift Language Version”“Use Legacy Swift Language Version” (SWIFT_VERSION) is required to be configured correctly for targets which use Swift. Use the [Edit &gt; Convert &gt; To Current Swift Syntax…] menu to choose a Swift version or use the Build Settings editor to configure the build setting directly.在pod的配置文件里面的Use Legacy Swift Language Version选择YES错误就消除了Pods-&gt;TARGETS-&gt;指定框架 -&gt; Build Settings -&gt; Use Legacy Swift Language Version * 问题2:–.lipo:can’t open input file:xxx(No such file or directory) PROJRCT-&gt; Build Settings -&gt; Build Active Architecture only-&gt;YES 其他问题后续收集再整理… 2&gt;发现框架过时,需要更新框架.由于3.0的更新,Swift各个主流框架都已经及时的推出了新的版本,例如:Alamofire 4.0.0 , SnapKit 3.0.0 , Kingfisher 3.1.0 , SwiftyJSON 也已经更新了专供Swift3的分支.所以,要更新框架以供使用. 1234pod &apos;SnapKit&apos;, &apos;~&gt; 3.0.0&apos;pod &apos;SwiftyJSON&apos;, :git =&gt; &apos;https://github.com/acegreen/SwiftyJSON.git&apos;, :branch =&gt; &apos;swift3&apos;pod &apos;Alamofire&apos;,&apos;~&gt; 4.0.0&apos;pod &apos;Kingfisher&apos;,&apos;~&gt; 3.1.0&apos; 可能会出现以下问题: * SnapKit框架问题: 看到200多个框架错误后凌乱了.都是3.0语法了,为什么还会报错,不在框架,在自己安装的cocoapods环境有关系. 解决方案:需要更新最新环境到cocoapods 1.1.0.rc.2 1sudo gem install cocoapods --pre 可以参照SnapKit的官方issues:https://github.com/SnapKit/SnapKit/issues/300如果没有安装 cocoapods可以参照之前写的博客.安装 cocoapods 1.1.0心得体会: * Alamofire框架问题: Alamofire/Source/ServerTrustPolicy.swift:243:41: Use of unresolved identifier ‘kSecTrustResultInvalid’ Alamofire的官方issues:https://github.com/Alamofire/Alamofire/issues/1541 解决方案:上面也提到了,更新最新的Alamofire框架. 1pod &apos;Alamofire&apos;,&apos;~&gt; 4.0.0&apos; 可能还遇到的问题: 12345[!] Unable to satisfy the following requirements:- `Alamofire (~&gt; 4.0.0)` required by `Podfile`Specs satisfying the `Alamofire (~&gt; 4.0.0)` dependency were found, but they required a higher minimum deployment target. 解决方法:Alamofire 4.0.0 最低要求系统版本9.0,已经将系统升高到9.0还是无法安装.目前的没有找到有效的解决方法,只有一个方案就是重新立项先集成框架,在把转接完的代码迁移到新的项目中去. 10月24日,更新解决方法.之前提示Alamofire 4.0.0, Podfile报错.需要在Podfile文件中指定最低系统9.0项目版本.platform :ios,&#39;9.0&#39;Alamofire的官方issues:https://github.com/Alamofire/Alamofire/issues/1639 * 可能还会有其他框架问题,目前还没有遇到.欢迎讨论.3.其他问题总结: * 关于重建工程来迁移到Swift3.0解决方案.前面也提到了,发现有个别问题无法解决,一直解决也是没有成效,于是使用目前来说最简洁的方法就重新建立工程. 先把新建的工程集成好最新支持Swift3.0的第三方框架,测试程序可不可以跑通后,再把之前转换完的代码一个分类一个分类迁移到新的工程里面. 至于手工拖入的第三方依赖库,应用跳转,按照之前集成好的照搬.或者重新集成. * Swift3.0语法的学习.1.官方已经给出文档以及转变说明.Apple Swift 3.0官方文档:The Swift Programming Language (Swift 3) 2.Apple Swift 3.0官方演变:apple/swift-evolution/releases/swift-3_0.md 其主要是废除了一些API,简化代码的书写,例如取出OC中的NS类前缀,C语言的风格,等等. 3.国外raywenderlich的Swift 3.0迁移介绍:https://www.raywenderlich.com/135655/whats-new-swift-3 * 后续持续补充.后记 对Swift3的书写方式还需要进一步的加强,虽然和之前的写法有着轻微的改动,使整体变的更加的简洁、严谨,但是稍不注意还是出现莫名其妙的报错. 展望Swift4,让暴风雨来的更猛烈些吧. 欢迎讨论、批评、指正.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Cocoapods进阶-屡试不爽，安装Cocoapods1.1.0最新心得及问题总结]]></title>
      <url>%2F2016%2F10%2F10%2FCocoapods%E8%BF%9B%E9%98%B6-%E5%B1%A1%E8%AF%95%E4%B8%8D%E7%88%BD%EF%BC%8C%E5%AE%89%E8%A3%85Cocoapods1.1.0%E6%9C%80%E6%96%B0%E5%BF%83%E5%BE%97%E5%8F%8A%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93!%2F</url>
      <content type="text"><![CDATA[安装淘宝源就直接跳过,安装十余次,分享下最近安装cocoapods的经验,仅仅提醒ruby版本问题之后的操作.如果还有不懂地方可以下方评论,会及时回答.12Error installing cocoapods: activesupport requires Ruby version &gt;= 2.2.2. 1.安装ruby1&gt;安装 RVMRVM: Ruby Version Manager, Ruby的版本管理器，包括Ruby的版本管理和Gem库管理(gemset)1curl -L get.rvm.io | bash -s stable 2&gt;安装home-brew(切记先安装home-brew,再安装ruby!!)1/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; home-brew地址:&lt;– 如果出现重复安装home-brew,不要怕. 会给你提示命令.It appears Homebrew is already installed. If your intent is to reinstall youshould do the following before running this installer again:1ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)&quot; 3&gt;再安装ruby版本(最新版本2.3.0)1rvm install 2.3.0 出现情况:1.安装不通过的话可以进行手动安装. Installing requirements for osx.Updating system…..Installing required packages: autoconf, automake, libtool, pkg-config, libyaml, readline, libksba, openssl|……..Error running ‘requirements_osx_brew_libs_install autoconf automake libtool pkg-config libyaml readline libksba openssl’,showing last 15 lines of /Users/MTKJ/.rvm/log/1469285314_ruby-2.3.0/package_install_autoconf_automake_libtool_pkg-config_libyaml_readline_libksba_openssl.log 12345678brew install autoconfbrew install automakebrew install lib toolbrew install apple-gcc42brew install libyamlbrew install libxsltbrew install libksbabrew install openssl 2 . Error running ‘__rvm_make -j 1’ 错误 ruby-2.3.0 - #extracting ruby-2.3.0 to /Users/xxxx/.rvm/src/ruby-2.3.0…-ruby-2.3.0 - #configuring………………………………………………|ruby-2.3.0 - #post-configuration.ruby-2.3.0 - #compiling………..Error running ‘__rvm_make -j 1’,showing last 15 lines of /Users/xxxx/.rvm/log/1476689284_ruby-2.3.0/make.logcompiling dln.ccompiling localeinit.ccreating verconf.hverconf.h updatedcompiling loadpath.ccompiling prelude.clinking static-library libruby.2.3.0-static.averifying static-library libruby.2.3.0-static.alinking shared-library libruby.2.3.0.dylibgenerating encdb.hencdb.h updatedmaking enc/bin/sh: /Applications/Xcode: No such file or directorymake: * [enc] Error 127++ return 2There has been an error while running make. Halting the installation./Users/xxxx/.rvm/bin/rvm: line 66: shell_session_update: command not found 安装xcode command line 后再次安装ruby. 1xcode-select --install 如果还是没有成功,查看自己xcode command line 是否选在正确版本. 4&gt;出现错误了,还是没有安装成功ruby.(没关系,卸载RVM,从新安装!)要记得关闭终端重新打开, 或者打开路径cd ~出现在~ 1sudo rm -rf .rvm .rvmrc /etc/rvmrc ;gem uninstall rvm 2.安装CocoaPods1&gt;安装cocoapods(普通版本)1sudo gem install cocoapods 2&gt;更新框架库1pod setup 可以查看框架镜像库的cd ~/.cocoapods 3&gt;更新cocoapods版本(测试版本,仅供特定条件)1sudo gem install cocoapods --pre]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[WKWebView替换UIWebView]]></title>
      <url>%2F2016%2F07%2F01%2FWKWebView%E6%9B%BF%E6%8D%A2UIWebView%2F</url>
      <content type="text"><![CDATA[前言 目前,WKWebView只在iOS8后才能用,但是大多数App需要支持iOS7以上的版本，所以兼容性方案就是,iOS7下用UIWebView，iOS8后WKWebView. 一、]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[免费开发者证书真机调试App ID失效问题:"Unable to add App ID because the '10' App ID limit in '7' days has been exceeded."解决方案总结。]]></title>
      <url>%2F2016%2F04%2F29%2F%E5%85%8D%E8%B4%B9%E5%BC%80%E5%8F%91%E8%80%85%E8%AF%81%E4%B9%A6%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95App%20ID%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[前言 今天(4月29日),笔者在做免费开发者证书真机调试的时候.发现如下问题: 问题:Unable to add App ID because the ‘10’ App ID limit in ‘7’ days has been exceeded.翻译如下: 寻求解决问题过程:第一次遇到,于是开始百度,发现百度没有这个问题.进行简要搜索时发现: 也是今天发布的寻找答案的,于是只能借助更强大的搜索: 在stack overflow中发现也有出现此问题: 链接如下:http://stackoverflow.com/questions/36923849/unable-to-add-app-id-because-the-10-app-id-limit-in-7-days-has-been-exceeded发现这个问题是4月28日晚上18点提交的,具体美国时间比中国晚一天,也就是说也是今天才发现的这个问题,看到解决方案.然后再开始跟苹果技术支持邮件联系得出如下答案:于是得出结论. 问题原因:这是苹果对Bundle Identifier进行了封锁. 推测:苹果于今天修改了规格,限制了开发者使用免证书的真机调试次数. 根据客服回电的答案得出,一个App ID,免证书真机调试只能进行10次,具体时间没有说明. 但是根据字面翻译意思在7天内只能创建10个项目文件(最主要的是Bundle Identifier名称),关于7天之外是否还能继续创建项目工程,笔者会持续更新. 5月5日测试,还是一直提示这个错误,持续猜想一个Apple ID,免证书真机调试只能进行10次. 5月10日测试,测试成功,7日内免证书真机调试10次可行. 5月12日测试,免证书真机调试生成描述文件后,View Details里面显示生成的Bundle Identifier更改成7天后过期,也就是说明一个Apple ID7天内可以只能生成10个Bundle Identifier. 这是苹果限制了Bundle Identifier的循环问题,减少了Bundle Identifier有效期时间,防止大量Bundle Identifier的堆积. 这样就可以及时去查看Bundle Identifier,等待Bundle Identifier到期后进行真机调试. 下图为显示Bundle Identifier的有效期(5月13日集中生成): 解决方案: 1.更换成开发者账号的App ID.(呵呵,你懂得.) 2.暂时解决方案,更换Bundle Identifier,把此前真机调试项目工程的Bundle Identifier更换成现在的项目工程的Bundle Identifier,(亲测可用!!) 3.重新创建项目工程的时候直接写成以前的真机测试通过的项目名字.(亲测可用!!) 解决方案会持续更新….. 友情提示:免费真机调试描述文件(.mobileprovision),有效期为90天,也就是说超过时间Bundle Identifier就不能用了.15月12日更新 .mobileprovision 有效期为更改7天. 解决办法:1.$99刀的开发者Apple ID.2.重新申请Apple ID,只申请1个描述文件(.mobileprovision),一直使用90天后再进行更换.(更换时间改为7天) 意外情况:一 . 更换Bundle Identifier还是没有解决: (亲测可用!!)当出现更换这里的Bundle Identifier还是没有用的时候 请更换项目工程里面的Bundle Identifier: 1.右键项目工程文件:显示包内容(Show Package Contents) 2.打开第一个文件: project.pbxproj 3.搜索: PRODUCT_BUNDLE_IDENTIFIER 进行替换4.发现有2个PRODUCT_BUNDLE_IDENTIFIER ,替换后面的 &gt;&gt;”.—-“&lt;&lt;,更换成以前自己可以真机调试Bundle Identifier这样也是可以的. 二 . 忘记之前创建的Bundle Identifier1.可以在偏好设置里面选择证书详情视图查找,Preferences-&gt;Accounts-&gt;View Details 2.根据排序,选择最近创建的Bundle Identifier]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac搭建Hexo博客]]></title>
      <url>%2F2016%2F03%2F18%2FMac%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[前言 总算是把Hexo给弄好了。在这期间遇到了各种问题，网上有的教程也有点老了，这里就再写一篇。最新的教程可以去Hexo官网查看。 准备安装XcodeHexo的编译可能依赖Xcode。 安装node.jsHexo是基于node.js的，所以要去官网上下载下来安装。版本可以选择稳定版(4.3.1)也可以选择最新版(5.7.0)。需要注意的是，Hexo 3.1.1测试的最低版本为0.12，所以安装的版本不要太旧，之前看到网上装的0.8.4的版本，我也这么装，结果有一大堆的报错。 注册Github账户在本地搭建好Hexo后可以将内容同步到github上，可以在网上浏览。可以去Github官网上去注册，注册的过程我就不罗嗦了，具体的过程可以去这个页面上跳到Github的那部分去看。其中配置SSH Keys的那部分，可以选择不配制，不配置的话以后每次提交的时候就需要手动输入账号密码，如果配置了的话就不需要了。 安装因为安装包中有些内容在墙外，所以可以换淘宝源，或者用 1npm install -g hexo-cli --no-optional cd进入你要安装的目录，如 1cd ~/hexo 然后初始化 1hexo init 初始化好之后,执行安装 1npm install 这样就已经安装完毕。 后续生成静态页面cd 到的目录，执行如下命令，生成静态页面至hexo\public\目录。 1hexo generate 本地启动执行好上面的命令之后,开始启动本地服务。再执行下面的命令： 1hexo sever 看到 INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.之后，就可以在浏览器中打开页面http://localhost:4000来看了。 写文章还是在你cd到的目录,执行new命令后,生成指定名称的文章至hexo\source\ _posts\ blogName.md。 1hexo new &quot;blogName&quot; blogName就是博客名。 接下来，就可以用Markdown编辑器写你的文章了。 1234567格式:title: postName #文章页面上的显示名称，可以任意修改，不会出现在URL中date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改categories: #文章分类目录，可以为空，注意:后面有个空格tags: #文章标签，可空，多标签请用格式[tag1,tag2,tag3]，注意:后面有个空格---这里开始使用markdown格式输入你的正文。 上传至Github安装git在安装之前，首先我们要确认在你的Github帐号的Repository(仓库)中有 用户名.github.io 的项目。在确认之后，就可以执行命令 1npm install hexo-deployer-git --save 配置账号配置 _config.yml 文件在Hexo安装的目录，如 ~/Document/hexo 中找到 _config.yml 文件。打开。翻到最后，找到 deploy 字样，改成如下格式： 1234deploy: type: git repo: https://github.com/用户名/用户名.github.io.git branch: master 需要注意的是：冒号后面有一个空格；使用github可以不用写branch那一行。如果要使用多个 deployer，可改成如下样式： 12345deploy:- type: git repo:- type: heroku repo: 同步输入命令1hexo deploy 执行,以后每次执行就可以依次输入下面三行命令： 123hero cleanhero generatehexo deploy 插件站点地图1npm install hexo-generator-sitemap --save 生成的sitemap.xml可以给搜索引擎收录使用。如果要生成百度的sitemap，使用以下命令： 1npm install hexo-generator-baidu-sitemap --save RSS订阅1npm install hexo-generator-feed@1.0.3 --save 主题更改Hexo提供了官网的主题, 初始化hexo时也会自动生成一个主题, Hexo还支持个性定制主题, 可以根据自己的喜好对主题进行修改, 更多主题可以在官网中找到 个性化博客的设置在博客的根目录下对喜爱的主题进行主题进行克隆 12345git clone git@github.com:yunlzheng/hexo-themes.git themes/writing#在./_config.yml，修改主题为writingtheme: writing#查看本地效果hexo g #hero generate简写hexo s #hexo server简写 安装主题的方法就是一句git命令：1git clone https://github.com/xx/hexo-theme-xxxx.git themes/xxxx 目录是否是什么无所谓，只要与_config.yml文件一致即可。 安装完成后，打开hexo_config.yml，修改主题为指定的主题名 1theme: xxxx 打开hexo\themes\xxxx目录，编辑主题配置文件_config.yml： 1234567891011121314151617181920212223242526272829menu: #配置页头显示哪些菜单# Home: / Archives: /archives Reading: /reading About: /about# Guestbook: /aboutexcerpt_link: Read More #摘要链接文字archive_yearly: false #按年存档widgets: #配置页脚显示哪些小挂件 - category# - tag - tagcloud - recent_posts# - blogrollblogrolls: #友情链接 - bruce sha&apos;s duapp wordpress: http://ibruce.duapp.com - bruce sha&apos;s javaeye: http://buru.iteye.com - bruce sha&apos;s oschina blog: http://my.oschina.net/buru - bruce sha&apos;s baidu space: http://hi.baidu.com/iburufancybox: true #是否开启fancybox效果duoshuo_shortname: buru #多说账号google_analytics:rss: 更新hero1npm update -g hero 更新主题12cd themes/modernistgit pull 更新插件：1npm update 在Mac下通过HEXO在Github上搭建博客http://www.jianshu.com/p/ecd51e8ef2fa hexo你的博客:http://ibruce.info/2013/11/22/hexo-your-blog/?utm_source=tuicool HEXO+Github,搭建属于自己的博客:http://www.jianshu.com/p/465830080ea9 通过Hexo在Github上搭建博客教程:http://www.jianshu.com/p/858ecf233db9 使用Hexo搭建博客（四），博客的部件和插件:http://www.jianshu.com/p/739bf1305e66]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[发布博客]]></title>
      <url>%2F2016%2F03%2F08%2F%E5%8F%91%E5%B8%83%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[0.打开hexo地址1cd /Users/..../hexo 1.写博客1hexo new &quot;My New Post&quot; 更新信息: Writing 2.启动服务器1hexo server 更新信息: Server 3.生成静态文件1hexo generate 更新信息: Generating 4.同步1hexo deploy 更新信息: Deployment]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux及Git命令总结。]]></title>
      <url>%2F2016%2F02%2F17%2FLinux%E5%8F%8AGit%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93%E3%80%82%2F</url>
      <content type="text"><![CDATA[常用Linux命令一、常用指令 显示文件或目录 1ls 列出文件详细信息列表(list) 1ls -l 列出当前目录下所有文件及目录，包括隐藏的文件(all) 1ls -a 创建目录 1mkdir 创建目录，若无父目录，则创建p(parent) 1mkdir -p 切换目录 1cd 创建空文件 1touch 创建带有内容的文件。 1echo 查看文件内容 1cat 拷贝 1cp 移动或重命名 1mv 删除文件 1rm 递归删除，可删除子目录及文件 1rm -r 强制删除 1rm -f 在文件系统中搜索某文件 1find 统计文本中行数、字数、字符数 1wc 在文本文件中查找某个字符串 1grep 删除空目录 1rmdir 树形结构显示目录，需要安装tree包 1tree 显示当前目录 1pwd 创建链接文件 1ln 二、系统管理命令 查询进程 1top 杀死进程 1kill 1kill pid号 1kill -9 pid号 1kill -15 pid号 显示网络状态信息 1netstat 查看网络情况 1ifconfig 清屏 1clear 三、Vim编辑器 编辑文件 1vi 文件名 编辑 1i 取消编辑 1esc按键 退出 1:q 保存并退出 1:wq 显示行号 1:set number 隐藏行号 1:set nonumber 常用Git命令一、新建代码库 在当前目录新建一个Git代码库 1git init 在当前目录新建并将其初始化为Git代码库 1git init **project-name** 克隆代码 1git clone **url** 二、配置Git的设置文件为 .gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 显示当前的Git配置 1git config --list 编辑Git配置文件 1git config -e [--global] 设置提交代码时的用户信息 12git config [--global] [user.name](http://user.name/) &quot;*name*&quot;git config [--global] user.email &quot;*email address*&quot; 三、增加/删除文件 添加指定文件到暂存区 1git add **file1** **file2** 添加指定目录到暂存区，包括子目录 1git add **dir** 添加当前目录的所有文件到暂存区 1git add . 添加每个变化前，都会要求确认，对于同一个文件的多处变化，可以实现分次提交 1git add -p 删除工作区文件，并且将这次删除放入暂存区 1git rm **file1** **file2** 停止追踪指定文件，但该文件会保留在工作区 1git rm --cached **file** 改名文件，并且将这个改名放入暂存区 1git mv **file-original** **file-renamed** 四、代码提交 提交暂存区到仓库区 1git commit -m **message** 提交暂存区的指定文件到仓库区 1git commit **file1** **file2** -m **message** 提交工作区自上次commit之后的变化，直接到仓库区 1git commit -a 提交时显示所有diff信息 1git commit -v 使用一次新的commit，替代上一次提交如果代码没有任何新变化，则用来改写上一次commit的提交信息 1git commit --amend -m **message** 重做上一次commit，并包括指定文件的新变化 1git commit --amend **file1** **file2** 五、分支 列出所有本地分支 1git branch 列出所有远程分支 1git branch -r 列出所有本地分支和远程分支 1git branch -a 新建一个分支，但依然停留在当前分支 1git branch **branch-name** 新建一个分支，并切换到该分支 1git checkout -b **branch** 新建一个分支，指向指定commit 1git branch **branch** **commit** 新建一个分支，与指定的远程分支建立追踪关系 1git branch --track **分支名字** **remote-branch** 切换到指定分支，并更新工作区 1git checkout **分支名字** 切换到上一个分支 1git checkout - 建立追踪关系，在现有分支与指定的远程分支之间 1git branch --set-upstream [branch] [remote-branch] 合并指定分支到当前分支 1git merge [branch] 选择一个commit，合并进当前分支 1git cherry-pick [commit] 删除分支 1git branch -d [branch-name] 删除远程分支 1$ git push origin --delete [branch-name] 1$ git branch -dr [remote/branch] 六、标签 列出所有tag 1git tag 新建一个tag在当前commit 1git tag [tag] 新建一个tag在指定commit 1git tag [tag] [commit] 删除本地tag 1git tag -d [tag] 删除远程tag 1git push origin :refs/tags/[tagName] 查看tag信息 1git show [tag] 提交指定tag 1git push [remote] [tag] 提交所有tag 1git push [remote] --tags 新建一个分支，指向某个tag 1git checkout -b [branch] [tag] 七、查看信息 显示有变更的文件 1git status 显示当前分支的版本历史 1git log 显示commit历史，以及每次commit发生变更的文件 1git log --stat 搜索提交历史，根据关键词 1git log -S [keyword] 显示某个commit之后的所有变动，每个commit占据一行 1git log [tag] HEAD --pretty=format:%s 显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件 1git log [tag] HEAD --grep feature 显示某个文件的版本历史，包括文件改名 1git log --follow [file] 1git whatchanged [file] 显示指定文件相关的每一次diff 1git log -p [file] 显示过去5次提交 1git log -5 --pretty --oneline 显示所有提交过的用户，按提交次数排序 1git shortlog -sn 显示指定文件是什么人在什么时间修改过 1git blame [file] 显示暂存区和工作区的差异 1git diff 显示暂存区和上一个commit的差异 1git diff --cached [file] 显示工作区与当前分支最新commit之间的差异 1git diff HEAD 显示两次提交之间的差异 1git diff [first-branch]...[second-branch] 显示今天你写了多少行代码 1git diff --shortstat &quot;@&#123;0 day ago&#125;&quot; 显示某次提交的元数据和内容变化 1git show [commit] 显示某次提交发生变化的文件 1git show --name-only [commit] 显示某次提交时，某个文件的内容 1git show [commit]:[filename] 显示当前分支的最近几次提交 1git reflog 八、远程同步 下载远程仓库的所有变动 1git fetch [remote] 显示所有远程仓库 1git remote -v 显示某个远程仓库的信息 1git remote show [remote] 增加一个新的远程仓库，并命名 1git remote add [shortname] [url] 取回远程仓库的变化，并与本地分支合并 1git pull [remote] [branch] 上传本地指定分支到远程仓库 1git push [remote] [branch] 强行推送当前分支到远程仓库，即使有冲突 1git push [remote] --force 推送所有分支到远程仓库 1git push [remote] --all 九、撤销 恢复暂存区的指定文件到工作区 1git checkout [file] 恢复某个commit的指定文件到暂存区和工作区 1git checkout [commit] [file] 恢复暂存区的所有文件到工作区 1git checkout . 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 1git reset **file** 重置暂存区与工作区，与上一次commit保持一致 1git reset --hard 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 1git reset **commit** 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 1git reset --hard **commit** 重置当前HEAD为指定commit，但保持暂存区和工作区不变 1git reset --keep **commit** 新建一个commit，用来撤销指定commit后者的所有变化都将被前者抵消，并且应用到当前分支 1git revert **commit** 暂时将未提交的变化移除，稍后再移入 1git stash 1git stash pop 十、其他 生成一个可供发布的压缩包 1git archive]]></content>
    </entry>

    
  
  
</search>
